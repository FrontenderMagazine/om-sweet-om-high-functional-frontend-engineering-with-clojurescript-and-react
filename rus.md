#Om милый Om: (высоко-)функциональное проектирование фронтенда с ClojureScript и React

В Prismatic мы твердо верим, что лучшие продукты получаются в результате союза продуманного дизайна и тщательного проектирования. [Эффективное проектирование][1] требует делать обоснованные предположения о том, что работает, создавая решения для быстрого тестирования гипотез и итераций, нацеленных на результат. Например, если вы читали о нашем недавнем [ре-дизайне ленты][2], значит вам известно о том, что мы тестировали три очень разных макета ленты в прошлом году, перед тем как вставить в дизайн, которым мы и большинство наших пользователей были довольны.

Постоянные эксперименты и итерации представляют для нас интересный технологичный вызов: создание фронтенд архитектуры, позволяющей быстро создавать и тестировать дизайн при сохранении приемлемой производительности для наших пользователей.

В частности, (как и для большинства команд создающих программное обеспечение) нашей основной целью стало увеличение производительности и вовлечение команды в написание кода, который:

* модульный, с минимальной связанностью компонентов
* простой и читабельный
* имеет минимум ошибок, насколько это возможно

По нашему опыту построения веб, iOS и бэкенд приложений мы обнаружили, что степень связанности и большинство ошибок напрямую зависят от управления изменениями состояния приложения. С [ClojureScript][3] и [Om][4](ClojureScript интерфейс для [React][5]) мы наконец то нашли ту архитектуру, которая снимет большую часть этого бремени для нас в вебе. Два месяца назад мы полностью переписали наше [веб-приложение][6] на эту архитектуру и это дало огромный прирост нашей эффективности при сохранении быстрой производительности.
![Prismatic][Prismatic]

Новая кодовая база занимает чуть меньше 5 тысяч строк ClojureScript (не включая библиотеки), что в пять раз меньше, чем было в нашей предыдущей кодовой базе. Конечно, размер это не главное. Каждый наш бэкенд разработчик внес значительный вклад в новую кодовую базу, что говорит о высокой читабельности и понятности кода.

Читая дальше, вы узнаете о том как мы ускорили наши итерации с Om, ClojureScript и React.

### ClojureScript

Серверная часть Prismatic построена на [Clojure][8] - красиво сконструированном, современном диалекте Lisp, работающем на JVM, который идеально подходит для задач проектирования программ в реальном мире. Clojure имеет превосходную поддержку функционального, дата-ориентированного программирования с эффективными неизменяемыми структурами данных. Так же он обладает очень выразительной поддержкой [атомарных, композируемых абстракций][9], и почти бесконечную расширяемость при помощи макросов.

Учитывая нашу любовь к Clojure, мы были в восторге от введения [ClojureScript][3] - диалекта Clojure компилирующегося в Javascript и дающее вебу все преимущества Clojure. Так же как и Closure, ClojureScript сохраняет высокую производительность благодаря использованию современных Javascript движков в сочетании с превосходной библиотекой [GoogleClosure][10].

#### Функциональное программирование

Функциональное программирование призывает писать чистые функции без побочных эффектов и всегда возвращающие один и тот же результат при одинаковом наборе входных данных. Зная, что функция не имеет побочных эффектов и глобальных ссылок, программист может быть уверен в том, что вызывая функцию он получит только вычисление результата. Чистые функции модульны по определению, что позволяет легче рассуждать о тестировании и составлении комплексных функций.

В ClojureScript все значения неизменяемы по-умолчанию. Более того, ClojureScript обладает эффективной реализацией [***постоянных***][11] иммутабельных хешей, векторов и списков. Вы не можете изменить эти структуры данных; вместо «модификаций» возвращается новая, обновленная структура данных. Разумная производительность при этом сохраняется путем структурного разделения. Данные архитектурные решения делают написание чистых функций быстрым и гарантируют, что вам можно не беспокоиться о том, что клиенты изменят ваши драгоценные данные без вашего ведома, тем не менее оставляя возможность создания явных изменяемых ссылок, когда это необходимо.

#### Макросы

ClojureScript так же включает в себя мощную систему макросов, которая позволяет расширять язык на уровне библиотеки, что было бы невозможно в других языках программирования. Макрос ClojureScript - это Clojure-функция, которая выполняется на этапе компиляции, что позволяет использовать Clojure в полную силу для построения нового кода из ее невычисленных аргументов. Этот мощный, но простой способ генерации кода, позволяет легко абстрагироваться от больших шаблонов, добавлять новый синтаксис для языка или оптимизировать сгенерированный код по размеру и производительности на стороне клиента.

Например, макрос ClojureScript `->>` «thread-last» поворачивает вложенные формы наоборот, делая их более читабельными как последовательность процедур. Учитывая полезность и общую применимость, реализация макроса может быть очень короткой:
```clojure
(defmacro ->>
  ([x form] `(~@(if (seq form) form [form]) ~x))
  ([x form & more] `(->> (->> ~x ~form) ~@more)))
```
Пример использования: принять весьма вложенные формы, которые преобразовывают вектор чисел, отфильтровать только нечетные, взять первые два, получить последний элемент усеченной последовательности, и увеличить его на единицу.
```clojure
(inc (last (take 2 (filter odd? [1 2 3 4 5]))))
```
Макрос позволяет написать эту последовательность операций в более читабельной форме, которая соответствует тому, как мы это воспринимаем:
```clojure
(->> [1 2 3 4 5]   ; the initial vector
     (filter odd?) ; after this step we have: (1 3 5)
     (take 2)      ; (1 3)
     last          ; 3
     inc)          ; 4
```
Другой, более сложный пример - [`core.async`][12], использующий макросы для привнесения goroutine (в духе языка Go от Google) в ClojureScript. Goroutine - это естественный путь выражения асинхронной модели, которая, как правило, часто возникает в веб-разработке, в синхронном стиле (прямолинейно, без функций обратного вызова). Как правило, поддержка такого стиля программирования должна быть включена в компилятор языка программирования, но макросы позволяют эффективно расширить язык, так что goroutine могут быть представлены как небольшая библиотека. Мы так же создали ряд собственных библиотек, использующих макросы чтобы добавить новый синтаксис для ClojureScript, в том числе [Plumbing][13], [Schema][14] и [om-tools][15].

### React

Тогда как Clojure привносит функциональную парадигму программирования на сторону данных веба, [React][5] привносит ее же в DOM, предоставляя простой и мощный инструмент для построения компонентных пользовательских интерфейсов. Если вы еще с ним не знакомы, мы очень Вам рекомендуем ознакомиться с тем, почему [Facebook построили React][16]. В документации React приведено его главное обещание: «Просто выразите то, как ваше приложение должно выглядеть в определенный момент времени и React будет автоматически управлять всеми UI изменениями, когда вы изменяете данные». 

#### Согласованность данных в DOM

Распространенной ошибкой в веб-разработке является частое усложнение взаимодействия между DOM и данными, которые он отображает. Когда часть данных изменяется, все соответствующие представления данных должны быть обновлены надлежащим образом для поддержки согласованности. Любое ограничение должно быть исполнено путем написания кода, оставляя возможности для ошибок. Таким образом большинство веб приложений ограничены в согласованности.

В самом простом решении данной проблемы, каждый компонент, имеющий возможность изменения части данных, должен знать о каждом компоненте, который связан с этими данными. В результате при масштабировании, сложность архитектуры растет квадратично с ростом количества компонентов:

![Хаос][Хаос]

Менее подвержена ошибкам «звездообразная» архитектура, которая сохраняет каноническое представление каждого участка состояния, и все компоненты, которые изменяются или представляют это состояние, общаются напрямую с центральным узлом:

![Звездообразная архитектура][Звездообразная архитектура]

«Звездообразная» архитектура уменьшает количественное ограничение к линейному количеству компонентов. Двухстороннее связывание шаблона, Последний Путь Делать Правильные Вещи, предоставляет абстракции, которые уменьшают шаблон, необходимый для реализации этого подхода. Но разработчик React, Pete Hunt [утверждает][19], что это не очень хорошо. Поскольку двухстороннее связывание шаблона - это достаточно сложная задача, чтобы быть решенной правильно, каждая библиотека изобретает свою собственную систему вокруг системы шаблонов, что почти невозможно расширить или поддерживать в долгосрочной перспективе.

React предлагает более простое решение «проблемы состояний», что сперва может показаться безумием. Вы просто пишите чистые Javascript функции, которые переводят ваши данные в виртуальное представление DOM. React вызывает эти функции один раз для генерации DOM каждого компонента, который загружает ваше приложение. Затем, каждый раз когда данные побуждают компонент измениться, React автоматически вызывает соответствующую функцию для пересоздания затронутой части пользовательского интерфейса. Концептуально, это все что нужно сделать - пользовательский интерфейс, становится просто функциональной проекцией состояния Вашего приложения.

Это, вероятно, звучит как кошмар производительности. Но, управляя виртуальным DOM, React может эффективно сравнить, что сейчас отображается на экране с тем, что должно отображаться, избегая медленных запросов к настоящему DOM. React вычисляет и выполняет наименьший набор возможных изменений для трансформации текущего DOM, чтобы соответствовать DOM виртуальному. Так как DOM манипуляции гораздо медленнее, чем Javascript вычисления, средняя производительность React часто совпадает (или даже [превосходит][20]) с другими общепринятыми подходами, в тоже время освобождая разработчика от рассуждений об управлении согласованностью между компонентами и обновлениями в результате изменения данных. Вся побочная сложность, естественно возникающая при мутации DOM, улетучивается.

### Om

Философия дизайна ядра в React по существу функциональная, и во многом это более соответствует функциональному языку ClojureScript чем Javascript. Om построен на React, продвигая его идеи дальше, используя неизменяемые структуры данных для представления состояния приложения, тем самым увеличивая производительность и архитектурные преимущества.

#### Единое, нормализованное состояние приложения

Правильный функциональный стиль, когда имеет смысл, избегает мутаций. Но интерактивные интерфейсы по определению постоянно меняются от одного состояния к другому в ответ на действия пользователя. В этом случае, наиболее функциональным решением будет добавление изменений в конец системы, с помощью единственной изменяемой ссылки, которая указывает на последнюю, неизменяемую структуру данных, представляющую полное состояние приложения в [нормализованном][21] формате.

Есть несколько важных преимуществ данного подхода.

Во-первых, есть единственная изменяемая ссылка, указывающая на глобальное состояние приложения. Локализация мутаций в одном месте минимизирует когнитивную сложность, что упрощает размышления о приложении.

Во-вторых, состояние собрано в единый неизменяемый объект. В конечном счете, состояние управляет всем приложением, что делает его наиболее прозрачным для разрабочиков, работающих с его кодовой базой. Если вы понимаете состояние, то вы понимаете ядро всего приложения; остальное «просто» логика для отображения и обновления состояния. Единое состояние имеет и другие интересные преимущества, как, например, обеспечение среза всего приложения и перемещение по ним бесплатно.

Наконец, состояние *нормализовано*: каждый кусочек информации представлен в одном месте. Так как React обеспечивает согласованность между DOM и прикладными данными, программист может сфокусироваться на том, чтобы состояние оставалось точным, в ответ на действия пользователя. Если состояние приложения нормализуется, то это обеспечивает согласованность по определению, полностью избегая возможности общих ошибок.

Тем не менее, есть несколько возможных проблем с использованием единого состояния приложения.

Во-первых, это выглядит противоречащим нашим функциональным идеалам инкапсуляции, модульности и композиции. В идеале, мы бы хотели чтобы каждый компонент имел доступ к точному подмножеству нужных ему данных, и был в состоянии отвечать на действия пользователя, изменяя релевантные данные необходимые в контекстно-свободной манере, без необходимости понимать всю глобальную структуру приложения.

Во-вторых, производительность React в некоторой степени полагается на модульность компонентов и их данных: когда данные изменяются, только компоненты, отвечающие за эти данные перерисовываются. Казалось бы, что собирая все состояние приложения в одном месте, это уничтожит это преимущество, требуя повторную (виртуальную) перерисовку всего приложения, независимо от того как мало данных изменилось.

Om предлагает решение этих проблем.

Om восстанавливает инкапсуляцию и модульность при помощи [курсоров][22]. Курсоры предоставляют собой обновляемые окна в особых участках состояния приложения (очень похоже на [zippers][23]), что позволяет компонентам получать ссылки только на релевантный участок глобального состояния, и обновлять его в контекстно-свободной манере.
![Пример курсоров][Пример курсоров]

Для решения проблемы производительности, Om  использует мощь ClojureScript и неизменяемых структур данных. Потому одна иммутабельная структура, представляет одни данные, что очень эффективно когда требуется показать, какие части глобального состояния изменились между циклами используя сравнение ссылок. Om использует эту возможность, чтобы быстро определить, какие компоненты подверглись изменению данных, и избежать вызова для определения изменений виртуального DOM React'a полностью для компонентов, которые не изменяются.

#### Пример

Люди идут в Prismatic, для того чтобы найти и обмениваться контента, с учетом их интересов. Они находят этот контент в ***каналах***, в которых упорядочено собраны ***истории***, каждая из которых автоматически помечена набором соответствующих тем. Пользователи могут следовать за интересующими темами, и увидеть больше историй об этом позже.

В стационарном состоянии это просто реализовать. Бэкенд посылает список тем, за которыми следует пользователь, и они используются для заполнения списков тем в UI, а так же отмечает галочку рядом с каждой темой отмеченной в истории. Например, здесь изображение из ленты Городского Исследования. Слева отображение того, что видит пользователь, если он не следует за темой Городского Исследования. Когда пользователь нажимает на кнопку «Следить» под заголовком ленты, это изменение должно быть передано на сервер, локальное состояние и несколько мест в пользовательском интерфейсе(выделено пурпурным цветом).
![Пример следования за темой со стрелочками][Пример следования за темой со стрелочками]

В общем, пользователь может следовать или не следовать за темой из нескольких компонентов, и обновленное состояние должно отобразиться во всех других компонентах. Управление этой сложностью в Om проста: каждый компонент получает курсор к каноническому хранилищу информации следуемой темы, полученный из глобального состояния и проецирует эту информацию в UI и/или изменяет его по мере необходимости.  Соответственно, компоненту делающему модификации не нужно беспокоиться о процессе, только беспокоиться о своей инкапсулированной ссылке в релевантном участке глобального состояния приложения, переданного курсором.

### Заключение

Мы нашли, что вместе, ClojureScript, React и Om предоставляют простой способ для управления данными, изменяющимися в течении долгого времени, одной из самых сложных проблем UI разработки. Все пользовательские взаимодействия и общение с бекендом всплывают к нашему единому состоянию приложения, которое разложено на компоненты, которые Om/React отрисовывают автоматически. Om автоматически управляет сохранением представления данных, через независимые компоненты и позволяет нам сосредоточится на основной логике, правящей нашим приложением.

Этот стек позволяет использовать концепции  функционального программирования при написании кода который проще, короче и легче в тестировании и обслуживании. Так как все, что идет на вход и на выход , инкапсулируется в одной функции, новые инженеры могут легко редактировать компонент, ничего не зная об остальной части приложения, что позволило всей нашей команде энергично взяться и вносить изменения, с очень маленьким входным порогом.

<i>Спасибо: [Scott Rabin][26], [Kevin Lynagh][27] и [Sean Grove][28] за вычитку черновика этой статьи</i>

[1]: http://blog.getprismatic.com/making-good-design-decisions/
[2]: http://blog.getprismatic.com/list-beats-grid-linear-feeds-perform-two-to-three-times-better-than-grids-2/
[3]: https://github.com/clojure/clojurescript
[4]: https://github.com/swannodette/om
[5]: http://facebook.github.io/react/
[6]: http://getprismatic.com/topic/Programming
[7]: img/Slice-1.png
[8]: http://clojure.org/
[9]: http://blog.getprismatic.com/software-engineering-at-prismatic/
[10]: https://developers.google.com/closure/
[11]: http://hypirion.com/musings/understanding-persistent-vector-pt-1
[12]: https://github.com/clojure/core.async
[13]: https://github.com/Prismatic/plumbing
[14]: https://github.com/Prismatic/schema
[15]: https://github.com/Prismatic/om-tools
[16]: http://facebook.github.io/react/blog/2013/06/05/why-react.html
[17]: img/point-to-point.gif
[18]: img/hub-and-spoke--1-.gif
[19]: http://youtu.be/x7cQ3mrcKaY
[20]: http://vuejs.org/perf/
[21]: http://en.wikipedia.org/wiki/Database_normalization
[22]: https://github.com/swannodette/om/wiki/Cursors
[23]: http://richhickey.github.io/clojure/clojure.zip-api.html
[24]: img/Cursor-example.png
[25]: img/follow_example_with_arrows.png
[26]: https://github.com/scottrabin
[27]: https://twitter.com/lynaghk
[28]: https://twitter.com/sgrove

[Prismatic]: https://github.com/FrontenderMagazine/om-sweet-om-high-functional-frontend-engineering-with-clojurescript-and-react/raw/master/img/Slice-1.png
[Хаос]: https://github.com/FrontenderMagazine/om-sweet-om-high-functional-frontend-engineering-with-clojurescript-and-react/raw/master/img/point-to-point.gif
[Звездообразная архитектура]: https://github.com/FrontenderMagazine/om-sweet-om-high-functional-frontend-engineering-with-clojurescript-and-react/raw/master/img/hub-and-spoke--1-.gif
[Пример курсоров]: https://github.com/FrontenderMagazine/om-sweet-om-high-functional-frontend-engineering-with-clojurescript-and-react/raw/master/img/Cursor-example.png
[Пример следования за темой со стрелочками]: https://github.com/FrontenderMagazine/om-sweet-om-high-functional-frontend-engineering-with-clojurescript-and-react/raw/master/img/follow_example_with_arrows.png
