В Prismatic мы твердо верим что лучшие продукты получаются в результате союза продуманного дизайна и тщательного проектирования. Эффективный дизайн требует создания предположений о том что работает, создавая решения для быстрого тестирования гипотез и итераций, нацеленных на результат. Например, если вы читали о нашем недавнем ре-дизайне ленты, значит вам известно о том, что мы тестировали три очень разных макета ленты в прошлом году, перед тем как вставить в дизайн, которым мы и большинство наших пользователей были довольны.

Постоянные эксперименты и итерации представляют для нас интересный технологичный вызов: создание front-end архитектуры, позволяющей быстро создавать и тестировать дизайн при сохранении приемлемой производительности для наших пользователей.

В частности, (как и для большинства команд создающих программное обеспечение) нашей основной целью стало увеличение производительности и вовлечение команды в написание кода, который:

* модульный, с минимальной связанностью компонентов
* простой и читабельный
* имеет минимум ошибок, насколько это возможно

По нашему опыту построения web, iOS и backend приложений мы обнаружили что много(если не большинство) связанности и багов напрямую зависит от управления изменениями состояния приложения. С ClojureScript и Om мы наконец то нашли архитектуру, которая решит большую часть этого бремени для нас в вебе. Два месяца назад мы полностью переписали наше веб-приложение на эту архитектуру и это дало огромный прирост нашей продуктивности при сохранении быстрой производительности.

Новая кодовая база занимает чуть меньше 5 тысяч строк ClojureScript(не включая библиотеки), что в пять раз меньше чем было в нашей предыдущей кодовой базе. Конечно, размер это не главное. Каждый наш backend - разработчик внес значительный вклад в новую кодовую базу, что говорит о высокой читабельности и понятности.

Читая дальше вы узнаете о том как мы ускорили наши итерации с Om, ClojureScript и React.

### ClojureScript

Серверная часть Prismatic построена на Clojure, красиво сконструированном, современном диалекте Lisp, работающем на JVM, идеально подходящим под проектирование программ в реальном мире. Clojure имеет превосходную поддержку функционального, дата-ориентированного программирования с эффективными иммутабельными структурами данных. Так же он обладает очень выразительной поддержкой атомарных, композируемых абстракций, и почти бесконечную расширяемость при помощи макросов.

Учитывая нашу любовь к Clojure, мы были в восторге от введения ClojureScript, диалекта Clojure компилирующегося в Javascript и дающее вебу все преимущества Clojure. ClojureScript так же сохраняет высокую производительность что и Clojure, используя современные движки Javascript в сочетании с превосходной библиотекой GoogleClosure.

#### Функциональное программирование

Функциональное программирование призывает писать чистые функции независимые от побочных эффектов и всегда возвращающие тот же результат при одинаковом наборе входных данных. Зная что функция не имеет побочных эффектов и глобальных ссылок, дает программисту уверенность в том, что вызывая функцию он получит только вычисление результата, ничего больше не делая. Чистые функции модульны по определению, что позволяет легче рассуждать о тестировании и составлении комплексных функций.

В ClojureScript все значения иммутабельны по умолчанию. Более того ClojureScript обладает эффективной реализацией ***персистентных*** иммутабельных хешей, векторов и списков. Вы не можете изменить эти структуры данных; вместо "модификаций" возвращается новая, обновленная структура данных, сохраняя разумную производительность, путем структурного разделения. Эти архитектурные решения делают написание чистых функций быстрым, гарантируя что вам можно не беспокоиться о том что клиенты изменят ваши драгоценные данные без вашего ведома, оставляя возможность создания явных изменяемых ссылок, когда это практично.

#### Макросы

ClojureScript так же включает в себя мощную систему макросов, которая позволяет расширять язык на уровне библиотеки, что было бы невозможно в других языках программирования. Макрос ClojureScript это Clojure-функция которая выполняется на этапе компиляции, позволяющая использовать Clojure в полную силу для построения нового кода из ее невыполненных аргументов. Это мощный, но простой способность генерации кода позволяет легко абстрагироваться от больших шаблонов, добавить новый синтаксис для языка, или оптимизировать сгенерированный код по размеру и производительности на стороне клиента.

Например, макрос ->> ClojureScript, "поток с конца" поворачивает вложенные формы наоборот, делая их более читабельными как последовательность процедур. Учитывая полезность и общую применимость, реализация макроса может быть очень короткой:
```clojure
(defmacro ->>
  ([x form] `(~@(if (seq form) form [form]) ~x))
  ([x form & more] `(->> (->> ~x ~form) ~@more)))
```
Случай использования, принять весьма вложенные формы, которые преобразовывают вектор чисел: отфильтровать только нечетные, взять первые два, получить последний элемент усеченной последовательности, и увеличить его на единицу.
```clojure
(inc (last (take 2 (filter odd? [1 2 3 4 5]))))
```
Макрос позволяет написать эту последовательность операций в более читабельной форме, которая соответствует тому как мы это воспринимаем:
```clojure
(->> [1 2 3 4 5]   ; the initial vector
     (filter odd?) ; after this step we have: (1 3 5)
     (take 2)      ; (1 3)
     last          ; 3
     inc)          ; 4
```
Другой, более сложный пример [`core.async`](https://github.com/clojure/core.async), использующая макросы для привнесения горутин(в духе языка Go от Google) в ClojureScript. Горутины это очень естественный путь выразить асинхронную модель -- которая как правило, часто возникает в веб-разработке -- в синхронном стиле(прямолинейно, без функций обратного вызова). Как правило, поддержка такого стиля программирования должна быть включена в компилятор языка программирования, но макросы позволяют эффективно расширить язык, так что горутины могут быть представлены как небольшая библиотека. Мы так же создали ряд собственных библиотек, использующих макросы чтобы добавить новый синтаксис для ClojureScript, в том числе [Plumbing](https://github.com/Prismatic/plumbing), [Schema](https://github.com/Prismatic/schema) и [om-tools](https://github.com/Prismatic/om-tools).

### React
Пока Clojure привносит функциональную парадигму программирования на сторону данных веба, [React](http://facebook.github.io/react/) привносит ее же в DOM, предоставляя простой и мощный инструмент для построения компонентных пользовательских интерфейсов. Если вы еще с ним не знакомы, мы очень Вам рекомендуем ознакомиться с постом Facebook, о том почему [они построили React](http://facebook.github.io/react/blog/2013/06/05/why-react.html). В документации React приведено его главное обещание: "Просто выразите то, как ваше приложение должно выглядеть в определенный момент времени и React будет автоматически управлять всеми UI изменениями когда вы изменяете данные". 

#### Согласованность данных в DOM

Распространенной ошибкой в веб-разработке является частое усложнение взаимодействия между DOM и данными которые он показывает. Когда кусок данных изменяется, все его представления должны быть обновлены надлежащим образом для поддержки согласованности данных. Любое ограничение должно быть исполнено путем написания кода, оставляя открытым возможность для ошибки, и большинство веб приложений таким образом ограничены в согласованности.

В наивном решении данной проблемы, каждый компонент имеющий возможность изменения части данных должен знать о каждом компоненте который связан с этими данными, в результате при масштабировании сложность архитектуры изменяется квадратично с количеством компонентов:

![](http://blog.getprismatic.com//content/images/2014/Jun/point-to-point.gif)

Менее подвержена ошибкам "звездообразная" архитектура которая сохраняет каноничное представление каждого участка состояния, и все компоненты, которые изменяются или представляют это состояние, общаются напрямую с центральным узлом:

![](http://blog.getprismatic.com/content/images/2014/Jun/hub-and-spoke--1-.gif)

"Звездообразная" архитектура уменьшает количественное ограничение к линейному количеству компонентов. Двух-стороннее связывание шаблона, последний Путь Делать Правильные Вещи, предоставляет абстракции, которые уменьшают шаблон, необходимый для реализации этого подхода. Но разработчик React, Pete Hunt [утверждает](http://youtu.be/x7cQ3mrcKaY) что это не очень хорошо. Поскольку двухстороннее связывание шаблона это сложная задача чтобы ее понять, каждая библиотека изобретает свою собственную систему вокруг системы шаблонов, что почти невозможно расширить или поддерживать в долгосрочной перспективе.

React предлагает более простое решение "проблемы состояний", что сначала может показаться безумием. Вы просто пишите чистые Javascript функции, которые переводят ваши данные в виртуальное представление DOM. React вызывает эти функции один раз для генерации DOM каждого компонента который загружает ваше приложение. Затем, каждый раз когда данные побуждают компонент изменяться, React автоматически вызывает соответствующую функцию для пересоздания затронутой части пользовательского интерфейса. Концептуально, это все что нужно сделать - пользовательский интерфейс, это просто функциональная проекция состояния Вашего приложения.

Это вероятно звучит как кошмар производительности. Но управляя виртуальным DOM, React может продуктивно что сейчас отображается на экране с тем что должно отображаться, избегая медленных запросов к настоящему DOM. React вычисляет и выполняет наименьший набор возможных изменений для трансформации текущего DOM, чтобы соответствовать DOM виртуальному. Так как DOM манипуляции гораздо медленнее чем Javascript вычисления, средняя производительность React часто совпадает(или даже [превосходит](http://vuejs.org/perf/)) с другими общими подходами, в тоже время освобождая разработчика от рассуждений об управлении согласованностью между компонентами и обновлений в результате изменений данных. Вся побочная сложность, естественно возникающая при мутации DOM, улетучивается.
