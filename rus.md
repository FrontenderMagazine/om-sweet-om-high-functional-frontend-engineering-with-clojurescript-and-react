# Om sweet Om: (high-)functional frontend engineering with ClojureScript and React

В Prismatic мы твердо верим что лучшие продукты получаются в результате союза продуманного дизайна и тщательного проектирования. [Эффективный дизайн](http://blog.getprismatic.com/making-good-design-decisions/) требует создания предположений о том что работает, создавая решения для быстрого тестирования гипотез и итераций, нацеленных на результат. Например, если вы читали о нашем недавнем [ре-дизайне ленты](http://blog.getprismatic.com/list-beats-grid-linear-feeds-perform-two-to-three-times-better-than-grids-2/), значит вам известно о том, что мы тестировали три очень разных макета ленты в прошлом году, перед тем как вставить в дизайн, которым мы и большинство наших пользователей были довольны.

Постоянные эксперименты и итерации представляют для нас интересный технологичный вызов: создание front-end архитектуры, позволяющей быстро создавать и тестировать дизайн при сохранении приемлемой производительности для наших пользователей.

В частности, (как и для большинства команд создающих программное обеспечение) нашей основной целью стало увеличение производительности и вовлечение команды в написание кода, который:

* модульный, с минимальной связанностью компонентов
* простой и читабельный
* имеет минимум ошибок, насколько это возможно

По нашему опыту построения веб, iOS и бэкенд приложений мы обнаружили что много(если не большинство) связанности и ошибок напрямую зависит от управления изменениями состояния приложения. С [ClojureScript](https://github.com/clojure/clojurescript) и [Om](https://github.com/swannodette/om)(ClojureScript интерфейс для [React](http://facebook.github.io/react/)) мы наконец то нашли архитектуру, которая снимет большую часть этого бремени для нас в вебе. Два месяца назад мы полностью переписали наше [веб-приложение](http://getprismatic.com/topic/Programming) на эту архитектуру и это дало огромный прирост нашей продуктивности при сохранении быстрой производительности.
![](https://raw.githubusercontent.com/FrontenderMagazine/om-sweet-om-high-functional-frontend-engineering-with-clojurescript-and-react/master/img/Slice-1.png)

Новая кодовая база занимает чуть меньше 5 тысяч строк ClojureScript(не включая библиотеки), что в пять раз меньше чем было в нашей предыдущей кодовой базе. Конечно, размер это не главное. Каждый наш бэкенд - разработчик внес значительный вклад в новую кодовую базу, что говорит о высокой читабельности и понятности.

Читая дальше вы узнаете о том как мы ускорили наши итерации с Om, ClojureScript и React.

### ClojureScript

Серверная часть Prismatic построена на [Clojure](http://clojure.org/), красиво сконструированном, современном диалекте Lisp, работающем на JVM, идеально подходящим под проектирование программ в реальном мире. Clojure имеет превосходную поддержку функционального, дата-ориентированного программирования с эффективными иммутабельными структурами данных. Так же он обладает очень выразительной поддержкой [атомарных, композируемых абстракций](http://blog.getprismatic.com/software-engineering-at-prismatic/), и почти бесконечную расширяемость при помощи макросов.

Учитывая нашу любовь к Clojure, мы были в восторге от введения [ClojureScript](https://github.com/clojure/clojurescript), диалекта Clojure компилирующегося в Javascript и дающее вебу все преимущества Clojure. ClojureScript так же сохраняет высокую производительность что и Clojure, используя современные движки Javascript в сочетании с превосходной библиотекой [GoogleClosure](https://developers.google.com/closure/).

#### Функциональное программирование

Функциональное программирование призывает писать чистые функции независимые от побочных эффектов и всегда возвращающие тот же результат при одинаковом наборе входных данных. Зная что функция не имеет побочных эффектов и глобальных ссылок, дает программисту уверенность в том, что вызывая функцию он получит только вычисление результата, ничего больше не делая. Чистые функции модульны по определению, что позволяет легче рассуждать о тестировании и составлении комплексных функций.

В ClojureScript все значения иммутабельны по умолчанию. Более того ClojureScript обладает эффективной реализацией [***постоянных***](http://hypirion.com/musings/understanding-persistent-vector-pt-1) иммутабельных хешей, векторов и списков. Вы не можете изменить эти структуры данных; вместо «модификаций» возвращается новая, обновленная структура данных, сохраняя разумную производительность, путем структурного разделения. Эти архитектурные решения делают написание чистых функций быстрым, гарантируя что вам можно не беспокоиться о том что клиенты изменят ваши драгоценные данные без вашего ведома, оставляя возможность создания явных изменяемых ссылок, когда это практично.

#### Макросы

ClojureScript так же включает в себя мощную систему макросов, которая позволяет расширять язык на уровне библиотеки, что было бы невозможно в других языках программирования. Макрос ClojureScript это Clojure-функция которая выполняется на этапе компиляции, позволяющая использовать Clojure в полную силу для построения нового кода из ее невыполненных аргументов. Это мощный, но простой способность генерации кода позволяет легко абстрагироваться от больших шаблонов, добавить новый синтаксис для языка, или оптимизировать сгенерированный код по размеру и производительности на стороне клиента.

Например, макрос `->>` ClojureScript, «thread-last» поворачивает вложенные формы наоборот, делая их более читабельными как последовательность процедур. Учитывая полезность и общую применимость, реализация макроса может быть очень короткой:
```clojure
(defmacro ->>
  ([x form] `(~@(if (seq form) form [form]) ~x))
  ([x form & more] `(->> (->> ~x ~form) ~@more)))
```
Случай использования, принять весьма вложенные формы, которые преобразовывают вектор чисел: отфильтровать только нечетные, взять первые два, получить последний элемент усеченной последовательности, и увеличить его на единицу.
```clojure
(inc (last (take 2 (filter odd? [1 2 3 4 5]))))
```
Макрос позволяет написать эту последовательность операций в более читабельной форме, которая соответствует тому как мы это воспринимаем:
```clojure
(->> [1 2 3 4 5]   ; the initial vector
     (filter odd?) ; after this step we have: (1 3 5)
     (take 2)      ; (1 3)
     last          ; 3
     inc)          ; 4
```
Другой, более сложный пример [`core.async`](https://github.com/clojure/core.async), использующая макросы для привнесения горутин(в духе языка Go от Google) в ClojureScript. Горутины это очень естественный путь выразить асинхронную модель -- которая как правило, часто возникает в веб-разработке -- в синхронном стиле(прямолинейно, без функций обратного вызова). Как правило, поддержка такого стиля программирования должна быть включена в компилятор языка программирования, но макросы позволяют эффективно расширить язык, так что горутины могут быть представлены как небольшая библиотека. Мы так же создали ряд собственных библиотек, использующих макросы чтобы добавить новый синтаксис для ClojureScript, в том числе [Plumbing](https://github.com/Prismatic/plumbing), [Schema](https://github.com/Prismatic/schema) и [om-tools](https://github.com/Prismatic/om-tools).

### React
Пока Clojure привносит функциональную парадигму программирования на сторону данных веба, [React](http://facebook.github.io/react/) привносит ее же в DOM, предоставляя простой и мощный инструмент для построения компонентных пользовательских интерфейсов. Если вы еще с ним не знакомы, мы очень Вам рекомендуем ознакомиться с постом Facebook, о том почему [они построили React](http://facebook.github.io/react/blog/2013/06/05/why-react.html). В документации React приведено его главное обещание: «Просто выразите то, как ваше приложение должно выглядеть в определенный момент времени и React будет автоматически управлять всеми UI изменениями когда вы изменяете данные». 

#### Согласованность данных в DOM

Распространенной ошибкой в веб-разработке является частое усложнение взаимодействия между DOM и данными которые он показывает. Когда кусок данных изменяется, все его представления должны быть обновлены надлежащим образом для поддержки согласованности данных. Любое ограничение должно быть исполнено путем написания кода, оставляя открытым возможность для ошибки, и большинство веб приложений таким образом ограничены в согласованности.

В наивном решении данной проблемы, каждый компонент имеющий возможность изменения части данных должен знать о каждом компоненте который связан с этими данными, в результате при масштабировании сложность архитектуры изменяется квадратично с количеством компонентов:

![](http://blog.getprismatic.com//content/images/2014/Jun/point-to-point.gif)

Менее подвержена ошибкам «звездообразная» архитектура которая сохраняет каноничное представление каждого участка состояния, и все компоненты, которые изменяются или представляют это состояние, общаются напрямую с центральным узлом:

![](http://blog.getprismatic.com/content/images/2014/Jun/hub-and-spoke--1-.gif)

«Звездообразная» архитектура уменьшает количественное ограничение к линейному количеству компонентов. Двух-стороннее связывание шаблона, последний Путь Делать Правильные Вещи, предоставляет абстракции, которые уменьшают шаблон, необходимый для реализации этого подхода. Но разработчик React, Pete Hunt [утверждает](http://youtu.be/x7cQ3mrcKaY) что это не очень хорошо. Поскольку двухстороннее связывание шаблона это сложная задача чтобы ее понять, каждая библиотека изобретает свою собственную систему вокруг системы шаблонов, что почти невозможно расширить или поддерживать в долгосрочной перспективе.

React предлагает более простое решение «проблемы состояний», что сперва может показаться безумием. Вы просто пишите чистые Javascript функции, которые переводят ваши данные в виртуальное представление DOM. React вызывает эти функции один раз для генерации DOM каждого компонента который загружает ваше приложение. Затем, каждый раз когда данные побуждают компонент изменяться, React автоматически вызывает соответствующую функцию для пересоздания затронутой части пользовательского интерфейса. Концептуально, это все что нужно сделать - пользовательский интерфейс, это просто функциональная проекция состояния Вашего приложения.

Это вероятно звучит как кошмар производительности. Но управляя виртуальным DOM, React может продуктивно сравнить что сейчас отображается на экране с тем что должно отображаться, избегая медленных запросов к настоящему DOM. React вычисляет и выполняет наименьший набор возможных изменений для трансформации текущего DOM, чтобы соответствовать DOM виртуальному. Так как DOM манипуляции гораздо медленнее чем Javascript вычисления, средняя производительность React часто совпадает(или даже [превосходит](http://vuejs.org/perf/)) с другими общими подходами, в тоже время освобождая разработчика от рассуждений об управлении согласованностью между компонентами и обновлений в результате изменений данных. Вся побочная сложность, естественно возникающая при мутации DOM, улетучивается.

### Om

Философия дизайна ядра в React по существу функциональная, и во много это более соответствует функциональному языку ClojureScript чем Javascript. Om построен на React, продвигая его идеи дальше, используя иммутабельные структуры данных для представления состояния приложения, тем самым увеличивая производительность и архитектурные преимущества.

#### Единое, нормализованное состояние приложения

Правильный функциональный стиль, когда практично, избегает мутаций. Но интерактивные интерфейсы по определению постоянно изменяются из одного состояния к другому в ответ на действия пользователя. В этом случае, наиболее функциональным решением будет добавление изменений в конец системы, с помощью единственной мутабельной ссылки, которая указывает на последнюю, неизменяемую структуру данных, представляющую полное состояние приложения в нормализованном формате.

Есть несколько важных преимуществ данного подхода.

Во первых, это единственная мутабельная ссылка, указывающая на глобальное состояние приложения. Локализация мутаций в одном месте минимизирует когнитивную сложность, что упрощает размышления о приложении.

Во вторых, состояние это собранный в единый иммутабельный объект. В конечном счете, состояние управляет всем приложением, это делает его наиболее прозрачным для инженеров, работающих с его кодовой базой. Если вы понимаете состояние, то вы понимаете ядро всего приложения; остальное «просто» логика для отображения и обновления состояния. Единое состояние имеет и другие интересные преимущества, например обеспечение среза всего приложения и перемещение по ним бесплатно.

Наконец, состояние *нормализовано*: каждый кусочек информации представлен в одном месте. Так React обеспечивает согласованность между DOM и прикладными данными, программист может сфокусироваться на том, чтобы состояние оставалось точным, в ответ на действия пользователя. Если состояние приложения нормализуется, то это обеспечивает согласованность по определению, полностью избегая возможности общих ошибок.

Тем не менее, есть несколько возможных проблем с использованием единого состояния приложения.

Во первых, это выглядит противоречащим нашим функциональным идеалам инкапсуляции, модульности и композиции. В идеале, мы бы хотели чтобы каждый компонент имел доступ к точному подмножеству нужных ему данных, и в состоянии отвечать на действия пользователя, изменяя релевантные данные необходимые в контекстно-свободной манере, без необходимости понимать всю глобальную структуру приложения.

Во вторых, производительность React зависит полагается в некоторой степени на модульность компонентов и их данных: когда данные изменяются, только компоненты отвечающие за эти данные перерисовываются. Собирая все состояние приложения в одном месте, похоже на то что он уничтожит эту область, требуя повторную (виртуальную) перерисовку всего приложения, независимо от того как мало данных изменилось.

Om предлагает решение этих проблем.

Om восстанавливает инкапсуляцию и модульность при помощи [курсоров](https://github.com/swannodette/om/wiki/Cursors). Курсоры предоставляют обновляемые окна в особых участках состояния приложения(очень похоже на zippers), что позволяет компонентам получать ссылки только на релевантный участок глобального состояния, и обновлять его в контекстно-свободной манере.
![Cursor example](https://raw.githubusercontent.com/FrontenderMagazine/om-sweet-om-high-functional-frontend-engineering-with-clojurescript-and-react/master/img/Cursor-example.png)

Для решения проблемы производительности, Om  использует мощь ClojureScript и постоянных структур данных. Потому одна иммутабельная структура, представляет одни данные, что очень эффективно когда требуется показать, какие части глобального состояния изменились между циклами используя сравнение ссылок. Om использует эту возможность, чтобы быстро определить, какие компоненты подверглись изменению данных, и избежать вызова для определения изменений виртуального DOM React'a полностью для компонентов, которые не изменяются.

#### Пример

Люди идут в Prismatic, для того чтобы найти и обмениваться контента, с учетом их интересов. Они находят этот контент в ***каналах***, в которых упорядочено собраны ***истории***, каждая из которых автоматически помечена набором соответствующих тем. Пользователи могут следовать за интересующими темами, и увидеть больше историй об этом позже.

В стационарном состоянии это просто реализовать. Бэкенд посылает список тем, за которыми следует пользователь, и они используются для заполнения списков тем в UI, а так же отмечает галочку рядом с каждой темой отмеченной в истории. Например, здесь изображение из ленты Городского Исследования. Слева отображение того, что видит пользователь, если он не следует за темой Городского Исследования. Когда пользователь нажимает на кнопку «Следить» под заголовком ленты, это изменение должно быть передано на сервер, локальное состояние и несколько мест в пользовательском интерфейсе(выделено пурпурным цветом).
![](https://raw.githubusercontent.com/FrontenderMagazine/om-sweet-om-high-functional-frontend-engineering-with-clojurescript-and-react/master/img/follow_example_with_arrows.png)

В общем, пользователь может следовать или не следовать за темой из нескольких компонентов, и обновленное состояние должно отобразиться во всех других компонентах. Управление этой сложностью в Om проста: каждый компонент получает курсор к каноническому хранилищу информации следуемой темы, полученный из глобального состояния и проецирует эту информацию в UI и/или изменяет его по мере необходимости.  Соответственно, компоненту делающему модификации не нужно беспокоиться о процессе, только беспокоиться о своей инкапсулированной ссылке в релевантном участке глобального состояния приложения, переданного курсором.

### Заключение

Мы нашли, что вместе, ClojureScript, React и Om предоставляют простой способ для управления данными, изменяющимися в течении долгого времени, одной из самых сложных проблем UI разработки. Все пользовательские взаимодействия и общение с бекендом всплывают к нашему единому состоянию приложения, которое разложено на компоненты, которые Om/React отрисовывают автоматически. Om автоматически управляет сохранением представления данных, через независимые компоненты и позволяет нам сосредоточится на основной логике, правящей нашим приложением.

Этот стек позволяет использовать концепции  функционального программирования при написании кода который проще, короче и легче в тестировании и обслуживании. Так как все, что идет на вход и на выход , инкапсулируется в одной функции, новые инженеры могут легко редактировать компонент, ничего не зная об остальной части приложения, что позволило всей нашей команде энергично взяться и вносить изменения, с очень маленьким входным порогом.

<i>Спасибо: [Scott Rabin](https://github.com/scottrabin), [Kevin Lynagh](https://twitter.com/lynaghk) и [Sean Grove](https://twitter.com/sgrove) за вычитку черновика этой статьи</i>

